import  os
from    os.path     import join
import  cobra
from    cobra       import Model, Reaction, Metabolite
from cobra.flux_analysis.loopless import loopless_solution
from cobra.util.solver import linear_reaction_coefficients
import  numpy       as np
import  scipy       as sp
import  csv         as cp
import pandas as pd
import  sys
import  re
#######################################################################################
# Function Definition
# hvmDoubleKnockout Evaluates the effect of enforcing a knockout state on two reacions
# on virus production (model generated by genHVM.py)

# Inputs:
# HVM               Integrated host-virus model
# HostRxn           Name of the host objective reaction

# Outputs:
# outputDf          Data frame with knocked out reactions and resulting virus optima
def hvmDoubleEnforcement(HVM,HostRxn,koVirus,fluxVarHost,fluxVarVirus,solver):
    """Reaction Double Knockouts
    new by OSS"""

    # [1] Optimise the HVM for host and virus objectives
    # Initial Setup
    HVM.solver = solver                                        #set solver for all optimisations
    hostIdx = next(index for index, reaction in enumerate(HVM.reactions) if reaction.id == HostRxn)
    virusIdx    = len(HVM.reactions) - 1
    objIdx      = [hostIdx, virusIdx]
    virusRxn = HVM.reactions[-1].id

    # Virus Optimisation
    virusObj    = HVM.reactions[-1]
    HVM.objective   = virusObj.id
    virusSol    = HVM.optimize()

    # [2] Knockout Analysis
    #Initiate data structures
    reactionA_Index = [None]
    reactionA_Names = [None]
    reactionB_Names = [None]
    reactionB_Index = [None]
    doubleKO_optima = [None]

    # Initiate loop
    nbofReactions = len(HVM.reactions)
    for ii in range(0,nbofReactions):
        # Conditional to exclude objective reactions and those that carry zero flux for virus optima
        if ((ii!=hostIdx) and (ii!=virusIdx) and (virusSol.fluxes[ii]!=0.0) and (koVirus.virus_optima_KO[ii]!=0.0) and (not HVM.reactions[ii].id.startswith("EX_"))):
            # Decide on what bounds to use based on FVA
            lbHost_A = fluxVarHost.minimum[ii]
            ubHost_A = fluxVarHost.maximum[ii]
            lbVirus_A = fluxVarVirus.minimum[ii]
            ubVirus_A = fluxVarVirus.maximum[ii]
            #the following is the default. It covers two cases; (ubHost<=ubVirus && lbHost<lbVirus) and (ubHost>ubVirus && lbHost<lbVirus)
            lowerbound_A = lbHost_A
            upperbound_A = lbHost_A - (lbHost_A-lbVirus_A)/2
            if (ubHost_A>ubVirus_A and lbHost_A>=lbVirus_A):
                upperbound_A = ubHost_A
                lowerbound_A = ubHost_A - (ubHost_A-ubVirus_A)/2
            if (ubHost_A<ubVirus_A and lbHost_A>lbVirus_A):
                lowerbound_A = lbHost_A
                upperbound_A = ubHost_A
            if lbHost_A == lbVirus_A and ubHost_A == ubHost_A:
                pass
            else:
                # Store the bounds for rxn A
                tempLB_A = HVM.reactions[ii].lower_bound
                tempUB_A = HVM.reactions[ii].upper_bound
                # Alter bounds of rxn A to value chosen
                HVM.reactions[ii].lower_bound = lowerbound_A
                HVM.reactions[ii].upper_bound = upperbound_A
                for jj in range(ii+1,nbofReactions):
                    # Conditional to exclude objective reactions and reactions that carry zero flux for virus optima and reactions that gave zero flux when knocked out on their own
                    if ((jj!=hostIdx) and (jj!=virusIdx) and (virusSol.fluxes[jj]!=0.0) and (koVirus.virus_optima_KO[jj]!=0.0) and (not HVM.reactions[jj].id.startswith("EX_"))):
                        print("Double enforcement: \t%i\t%s\t%i\t%s" % (ii, HVM.reactions[ii].id, jj, HVM.reactions[jj].id))
                        # Store reaction info
                        reactionA_Index.append(ii)
                        reactionA_Names.append(HVM.reactions[ii].id)
                        reactionB_Index.append(jj)
                        reactionB_Names.append(HVM.reactions[jj].id)
                        # Store the bounds for rxn B
                        tempLB_B = HVM.reactions[jj].lower_bound
                        tempUB_B = HVM.reactions[jj].upper_bound
                        # Decide on what bounds to use based on FVA
                        lbHost_B = fluxVarHost.minimum[jj]
                        ubHost_B = fluxVarHost.maximum[jj]
                        lbVirus_B = fluxVarVirus.minimum[jj]
                        ubVirus_B = fluxVarVirus.maximum[jj]
                        #the following is the default. It covers two cases; (ubHost<=ubVirus && lbHost<lbVirus) and (ubHost>ubVirus && lbHost<lbVirus)
                        lowerbound_B = lbHost_B
                        upperbound_B = lbHost_B - (lbHost_B-lbVirus_B)/2
                        if (ubHost_B>ubVirus_B and lbHost_B>=lbVirus_B):
                            upperbound_B = ubHost_B
                            lowerbound_B = ubHost_B - (ubHost_B-ubVirus_B)/2
                        if (ubHost_B<ubVirus_B and lbHost_B>lbVirus_B):
                            lowerbound_B = lbHost_B
                            upperbound_B = ubHost_B
                        if lbHost_B == lbVirus_B and ubHost_B == ubHost_B:
                            doubleKO_optima.append(np.nan)
                        else:
                            # Alter bounds of rxn B to value chosen
                            HVM.reactions[jj].lower_bound = lowerbound_B
                            HVM.reactions[jj].upper_bound = upperbound_B
                            # Optimise the model for virus production
                            doubleKO_optima.append((HVM.slim_optimize() / virusSol.objective_value) * 100)
                            # Return rxn B to original bounds
                            HVM.reactions[jj].lower_bound = tempLB_B
                            HVM.reactions[jj].upper_bound = tempUB_B
                # Return rxn A to original bounds
                HVM.reactions[ii].lower_bound = tempLB_A
                HVM.reactions[ii].upper_bound = tempUB_A
    print("done")

    # [4] Output
    outputDf = pd.DataFrame(data=reactionA_Index, columns=["rxnAid"])
    outputDf = outputDf.assign(rxnAname=reactionA_Names)
    outputDf = outputDf.assign(rxnBid=reactionB_Index)
    outputDf = outputDf.assign(rxnBname=reactionB_Names)
    outputDf = outputDf.assign(doubleKOoptima=doubleKO_optima)
    return outputDf

import  os
from    os.path     import join
import  cobra
from    cobra       import Model, Reaction, Metabolite
from cobra.flux_analysis.loopless import loopless_solution
import  numpy       as np
import  scipy       as sp
import  csv         as cp
import pandas as pd
import  sys
import  re
#######################################################################################
# Function Definition
# hvmEnforce Evaluates the effect of enforcing a host-optimal state on virus
# production (model generated by genHVM.py)

# Inputs:
# HVM               Integrated host-virus model
# HostRxn           Name of the host objective reaction

# Outputs:
# enfVirus          Vector of virus optima values with additional host-constraint

def hvmEnforce(HVM,HostRxn,fluxVarHost,fluxVarVirus,solver):
    "Host Enforcement"

    # [1] Optimise the HVM for host and virus objectives
    # Initial Setup
    HVM.solver = solver                                        #set solver for all optimisations
    hostIdx = next(index for index, reaction in enumerate(HVM.reactions) if reaction.id == HostRxn)
    virusIdx    = len(HVM.reactions) - 1
    objIdx      = [hostIdx,virusIdx]
    virusRxn = HVM.reactions[-1].id

    # Host Optimisation
    hostObj     = HVM.reactions[hostIdx]
    HVM.objective   = hostObj.id
    hostSol     = HVM.optimize()
    print("Host optimization objective: {}".format(hostSol))

    # Virus Optimisation
    virusObj    = HVM.reactions[-1]
    HVM.objective   = virusObj.id
    virusSol    = HVM.optimize()
    print("Virus  optimization objective: {}".format(virusSol))

    # [2] Host Optimal Enforcement (HOE)
    enfVirus            = np.zeros(shape=(len(HVM.reactions),5))

    # Initiate loop
    nbofReactions = len(HVM.reactions)
    reactionNames = [None] * nbofReactions
    for ii in range(len(HVM.reactions)):

        # Conditional to exclude objective reactions and those that carry zero flux for virus optima
        if ((ii!=hostIdx) and (ii!=virusIdx) and (virusSol.fluxes[ii]!=0.0) and (not HVM.reactions[ii].id.startswith("EX_"))):

            print("{}/{}\tEnforcement: {}\t".format(ii, nbofReactions, HVM.reactions[ii].id))
            # Store reaction info
            reactionNames[ii] = HVM.reactions[ii].id
            enfVirus[ii,0] = ii
            # Store original fluxes under host and virus optimisation
            enfVirus[ii,1] = hostSol.fluxes[ii]
            enfVirus[ii,2] = virusSol.fluxes[ii]
            # Store the bounds
            tempLB = HVM.reactions[ii].lower_bound
            tempUB = HVM.reactions[ii].upper_bound

            # Alter bounds to the value in HOS
            HVM.reactions[ii].lower_bound = hostSol.fluxes[ii]
            HVM.reactions[ii].upper_bound = hostSol.fluxes[ii]
            # Optimise the model for virus production and store result
            enfVirus[ii,3] = HVM.slim_optimize()
            
            # Decide on what bounds to use based on FVA
            lbHost = fluxVarHost.minimum[ii]
            ubHost = fluxVarHost.maximum[ii]
            lbVirus = fluxVarVirus.minimum[ii]
            ubVirus = fluxVarVirus.maximum[ii]
            #the following is the default. It covers two cases; (ubHost<=ubVirus && lbHost<lbVirus) and (ubHost>ubVirus && lbHost<lbVirus)
            lowerbound = lbHost
            upperbound = lbHost - (lbHost-lbVirus)/2
            if (ubHost>ubVirus and lbHost>=lbVirus):
                upperbound = ubHost
                lowerbound = ubHost - (ubHost-ubVirus)/2
            if (ubHost<ubVirus and lbHost>lbVirus):
                lowerbound = lbHost
                upperbound = ubHost
            if lbHost == lbVirus and ubHost == ubVirus:
                enfVirus[ii,4] = np.nan
            else:
                # Alter bounds to the values from FVA analysis
                HVM.reactions[ii].lower_bound = lowerbound
                HVM.reactions[ii].upper_bound = upperbound
                # Optimise the model for virus production and store result
                enfVirus[ii,4] = HVM.slim_optimize()
                
            # Return to original bounds
            HVM.reactions[ii].lower_bound = tempLB
            HVM.reactions[ii].upper_bound = tempUB
        else:
            enfVirus[ii,3] = np.nan
            enfVirus[ii,4] = np.nan

    # [3] Post Analysis
    # Remove nan values 
    # Convert to % of original optima
    for ii in range(len(HVM.reactions)):
        enfVirus[ii,3] = (enfVirus[ii,3] / virusSol.objective_value) * 100
        enfVirus[ii,4] = (enfVirus[ii,4] / virusSol.objective_value) * 100

    # [4] Output
    outputDf = pd.DataFrame(data=enfVirus, columns=["index", "rxn flux when host optimized", "rxn flux when virus optimized", "virus optimum when flux is optimal for host", "virus optimum when boundaries are enforced"])
    outputDf = outputDf.assign(name=reactionNames)
    return outputDf
